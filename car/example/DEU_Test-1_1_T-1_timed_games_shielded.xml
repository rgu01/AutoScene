<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// Generated scenario starts
const int P = 1;
const uint16_t MAXTIME = 30;
const int MAXP = 2;
const int NONE = -1;
const int MAXL = 4;
const int MAXSO = 1;
const int MAXDO = 1;
const int MAXTP = 69;
const int MAXPRE = 1;
const int MAXSUC = 1;
const double THRESHOLD_COLLISION = 2;
const double THRESHOLD_REACH = 0.5;
const double TIMESTEPSIZE = 0.1;
const double RADAR = 100;
const uint8_t N1 = 1;
const uint8_t N2 = 4;
const uint8_t MAXACT = 2;
typedef int[0,MAXACT-1] act_id_t;
const uint8_t BASE = 10;
const uint8_t EXPONENT = 3;
const uint8_t MAXOBS = 1;
typedef int[0,MAXOBS-1] obs_id_t;

const uint8_t M = 77;
const uint8_t T = 84;
const uint8_t N = 78;
const int32_t ALL = -32767;

typedef int[-1,65535] id_t;

typedef struct {
    int32_t x;
    int32_t y;
}ST_IPOINT;

typedef struct {
    double x;
    double y;
}ST_DPOINT;

typedef struct {
    ST_IPOINT ends[2];
}ST_DLINE;

typedef struct {
    ST_IPOINT points[MAXP];
    bool dashLine;
}ST_BOUND;

typedef struct {
    id_t ID;
    ST_BOUND left;
    ST_BOUND right;
    id_t predecessor[MAXPRE];
    id_t successor[MAXSUC];
    id_t adjLeft;
    bool dirLeft;
    id_t adjRight;
    bool dirRight;
}ST_LANE;

typedef struct {
    bool collide; // collision
    bool outside; // outside road
    bool reach;   // reach the goal
}ST_DETECTION;

typedef struct {
    ST_DPOINT position;
    double velocity;
    double orientation;
    double acceleration;
    double accRate;
    double yawRate;
}ST_DSTATE;

typedef struct {
    ST_IPOINT position;
    int32_t velocity;
    int32_t orientation;
    int32_t acceleration;
    int32_t accRate;
    int32_t yawRate;
    ST_DETECTION detection;
}ST_ISTATE;

typedef struct {
    hybrid clock x;
    hybrid clock y;
    hybrid clock velocity;
    hybrid clock orientation;
    hybrid clock acceleration;
    //hybrid clock accRate;
    //hybrid clock yawRate;
}ST_DYNAMICS;

typedef struct {
    ST_IPOINT center;
    int32_t width;
    int32_t length;
    int32_t orientation;
}ST_RECTANGLE;

typedef struct {
    int32_t maxVelocity;
    int32_t minVelocity;
    int32_t maxOrientation;
    int32_t minOrientation;
}ST_RULES;

typedef struct {
    ST_IPOINT goal;
}ST_PLANNING;

typedef struct {
    int32_t time;
    ST_DSTATE dState;
}ST_PAIR;
const ST_BOUND leftLane1 = {{{0, 4000}, {75000, 4000}}, false};
const ST_BOUND rightLane1 = {{{0, 0}, {75000, 0}}, false};
const ST_LANE lane1 = {1, leftLane1, rightLane1, {NONE}, {3}, 2, true, NONE, false};

const ST_BOUND leftLane2 = {{{0, 8000}, {75000, 8000}}, false};
const ST_BOUND rightLane2 = {{{0, 4000}, {75000, 4000}}, false};
const ST_LANE lane2 = {2, leftLane2, rightLane2, {NONE}, {4}, NONE, false, 1, true};

const ST_BOUND leftLane3 = {{{75000, 4000}, {150000, 4000}}, false};
const ST_BOUND rightLane3 = {{{75000, 0}, {150000, 0}}, false};
const ST_LANE lane3 = {3, leftLane3, rightLane3, {1}, {NONE}, 4, true, NONE, false};

const ST_BOUND leftLane4 = {{{75000, 8000}, {150000, 8000}}, false};
const ST_BOUND rightLane4 = {{{75000, 4000}, {150000, 4000}}, false};
const ST_LANE lane4 = {4, leftLane4, rightLane4, {2}, {NONE}, NONE, false, 3, true};

const ST_LANE laneNet[MAXL] = {lane1, lane2, lane3, lane4};

const bool staticObsExists = true;
const ST_RECTANGLE staticObs[MAXSO] = {{{65000, 2250}, 2000, 4500, 300}};

const ST_PLANNING planning = {{85000, 2000}};


// Generated scenario ends

/** Shielding */
/*capture 1*/ import "/home/rgu01/Uppaal/StagedShieldSynthesis/car/libshield.so" /* end 1*/
{
    bool allow(uint8_t type, int value);
    int get_action(int &amp;type[5], int32_t &amp;value[5]);
    int set_cps_state(int32_t x, int32_t y, int32_t velocity, int32_t orientation, int32_t acceleration, int32_t accRate, int32_t yawRate, bool collide, bool outside, bool reach);
    int set_obs_state(int32_t id, int32_t x, int32_t y, int32_t velocity, int32_t orientation, int32_t acceleration, int32_t accRate, int32_t yawRate, bool collide, bool outside, bool reach);
    
    int32_t get_obs_position_x(int id);
    int32_t get_obs_position_y(int id);
    int32_t get_obs_velocity(int id);
    int32_t get_obs_orientation(int id);
    int32_t get_obs_acceleration(int id);
    int32_t get_obs_accRate(int id);
    int32_t get_obs_yawRate(int id);
    int32_t get_obs_detection_collide(int id);
    int32_t get_obs_detection_outside(int id);
    int32_t get_obs_detection_reach(int id);

    int32_t get_cps_position_x();
    int32_t get_cps_position_y();
    int32_t get_cps_velocity();
    int32_t get_cps_orientation();
    int32_t get_cps_acceleration();
    int32_t get_cps_accRate();
    int32_t get_cps_yawRate();
    int32_t get_cps_detection_collide();
    int32_t get_cps_detection_outside();
    int32_t get_cps_detection_reach();
};

broadcast chan perform[MAXACT],decide,sense,start,end;
//chan priority decide&lt;default&lt;sense;

//NOTE: when overflow happens, the sign of the number will be changed
//but this function has no assertion about overflow
int32_t d2i(double value) {
    return fint(value*pow(BASE,EXPONENT));
}

double i2d(int32_t value) {
    return value/pow(BASE,EXPONENT);
}

int32_t min(const int32_t v1, const int32_t v2){
    return v1 &lt; v2? v1:v2;
}

int32_t max(const int32_t v1, const int32_t v2){
    return v1 &gt; v2? v1:v2;
}

const int32_t INC_ACC = d2i(0.2);
const int32_t DEC_ACC = d2i(-0.1);
const int32_t CONST_ACC = d2i(0);
const int32_t INC_DIR = d2i(0.2);
const int32_t DEC_DIR = d2i(-0.2);
const int32_t CONST_DIR = d2i(0);
const int32_t MAX_ACC = d2i(1);
const int32_t MIN_ACC = d2i(-1);
const int32_t MAX_V = d2i(2);
const int32_t MIN_V = d2i(-1);
const int32_t PI = d2i(M_PI);

typedef int[-1,1] acc_t;
const double ACC_GRA = 1; //granularity of acceleration
typedef int[-1,1] dir_t;
const double DIR_GRA = 1; //granularity of turning

/** variables start **/
ST_ISTATE cps_i_state, obs_i_state[1];
ST_DYNAMICS cps_dynamic, obs_dynamic[1]; 
ST_RECTANGLE cps_shape, obs_shape[1]; 
clock g_time;
hybrid clock rSafe, rProgress;
int count = 0;
//int32_t reward = 0;
int32_t distanceToGoal = 0;
int[-100,100] FRISKY = 0;     //rate of reward safe
int[-100,100] FPROGRESS = 0; //rate of reward progress
bool shielded = false;
/** variables end **/

/** test start **/
int32_t distanceToStaticObs = 0;
/** test end **/

double mTimeStep(const double value) {
    return value*TIMESTEPSIZE;
}

int32_t getDisP2P(const ST_IPOINT &amp;p1, const ST_IPOINT &amp;p2) {
    double distance = 0.0;
    double rx1 = i2d(p1.x), ry1 = i2d(p1.y);
    double rx2 = i2d(p2.x), ry2 = i2d(p2.y);
    distance = sqrt(pow(rx1 - rx2, 2) + pow(ry1 - ry2, 2));

    return d2i(distance);
}

// Function to count non-zero elements in a 2D array
int check_pts_num(const ST_IPOINT lane_pts[MAXP]) {
    uint16_t count = 0;
    // NONE or 0?
    while (count &lt; MAXP &amp;&amp; (lane_pts[count].x != NONE || lane_pts[count].y != NONE)){
        count++;
    }
    return count;
}

// Function to calculate the corner points of a rectangle
void calculateCornerPoints(ST_RECTANGLE veh_state, ST_IPOINT &amp;corners[4]) {
    double halfLength = i2d(veh_state.length)/2.0;
    double halfWidth = i2d(veh_state.width)/2.0;
    double angle = i2d(veh_state.orientation);

    // Calculate the coordinates of each corner point based on the center, length, width, and orientation
    corners[0].x = d2i(i2d(veh_state.center.x) + halfLength*cos(angle) - halfWidth*sin(angle));
    corners[0].y = d2i(i2d(veh_state.center.y) + halfLength*sin(angle) + halfWidth*cos(angle));

    corners[1].x = d2i(i2d(veh_state.center.x) + halfLength*cos(angle) + halfWidth*sin(angle));
    corners[1].y = d2i(i2d(veh_state.center.y) + halfLength*sin(angle) - halfWidth*cos(angle));

    corners[2].x = d2i(i2d(veh_state.center.x) - halfLength*cos(angle) + halfWidth*sin(angle));
    corners[2].y = d2i(i2d(veh_state.center.y) - halfLength*sin(angle) - halfWidth*cos(angle));

    corners[3].x = d2i(i2d(veh_state.center.x) - halfLength*cos(angle) - halfWidth*sin(angle));
    corners[3].y = d2i(i2d(veh_state.center.y) - halfLength*sin(angle) + halfWidth*cos(angle));
}

// Checking if a point is inside a polygon
bool point_in_polygon(ST_IPOINT point, ST_IPOINT polygon[4])
{
    int num_vertices = 4, i = 0;
    int32_t x = point.x;
    int32_t y = point.y;
    double x_intersection;
    bool inside = false;
 
    // Store the first point in the polygon and initialize
    // the second point
    ST_IPOINT p1 = polygon[0], p2;
 
    // Loop through each edge in the polygon
    for (i = 1; i &lt;= num_vertices; i++) {
        // Get the next point in the polygon
        p2 = polygon[i % num_vertices];
 
        // Check if the point is above the minimum y
        // coordinate of the edge
        if (y &gt; min(p1.y, p2.y)) {
            // Check if the point is below the maximum y
            // coordinate of the edge
            if (y &lt;= max(p1.y, p2.y)) {
                // Check if the point is to the left of the
                // maximum x coordinate of the edge
                if (x &lt;= max(p1.x, p2.x)) {
                    // Calculate the x-intersection of the
                    // line connecting the point to the edge
                    x_intersection = (y - p1.y) * (p2.x - p1.x)/(p2.y - p1.y) + p1.x;
 
                    // Check if the point is on the same
                    // line as the edge or to the left of
                    // the x-intersection
                    if (p1.x == p2.x || x &lt;= x_intersection) {
                        // Flip the inside flag
                        inside = !inside;
                    }
                }
            }
        }
 
        // Store the current point as the first point for
        // the next iteration
        p1 = p2;
    }
 
    // Return the value of the inside flag
    return inside;
}

// check if veh_state are not covered by a single lane, or if vehicle rectangle touches the edge of the lane
uint8_t check_inlane_lane_single(const ST_LANE lane, ST_RECTANGLE veh_state) {
    uint8_t num_box = 0;
    uint8_t i_box = 0, i_veh = 0;
    uint8_t inlane_pts_num = 0;

    ST_IPOINT veh_corners[4];
    ST_IPOINT box_corners[4];
    // Calculate the corner points
    calculateCornerPoints(veh_state, veh_corners);

    // check the number of points in the lane
    num_box = check_pts_num(lane.left.points) - 1;
    for (i_box = 0; i_box &lt; num_box &amp;&amp; inlane_pts_num &lt; 4; i_box++){
        // define the corner of the road box
        box_corners[0] = lane.right.points[i_box];
        box_corners[1] = lane.right.points[i_box + 1];
        box_corners[2] = lane.left.points[i_box + 1];
        box_corners[3] = lane.left.points[i_box];
        // check if the inlane status of the vehicle box to the current box
        for(i_veh = 0; i_veh &lt; 4; i_veh++){
            if(point_in_polygon(veh_corners[i_veh],box_corners)){
                inlane_pts_num++;
            }
        }   
    }

    return inlane_pts_num;
}

bool check_inlane_laneNet(const ST_RECTANGLE veh_state) {
    uint8_t i_lane = 0, inlane_pts_num = 0;
    bool inside = false;

    for(i_lane = 0; i_lane &lt; MAXL &amp;&amp; inlane_pts_num&lt;4; i_lane++){
        inlane_pts_num += check_inlane_lane_single(laneNet[i_lane], veh_state);
    }
    
    if(inlane_pts_num &gt;= 4) {
        inside = true;
    }
    else {
        inside = false;
    }

    return inside;
}

int32_t compute_approximating_circle_radius(int32_t ego_length, int32_t ego_width) {
    double length = i2d(ego_length);
    double width = i2d(ego_width);
    double square_length, diagonal_square, approx_radius;

    if (length &lt;= 0 || width &lt;= 0) {
        return -1;
    }

    if (fabs(length) &lt; 1e-6 &amp;&amp; fabs(width) &lt; 1e-6) {
        return 0;
    }
    // Divide rectangle into 3 smaller rectangles
    square_length = length/3.0;
    // Calculate minimum radius
    diagonal_square = sqrt(pow(square_length/2.0, 2) + pow(width/2.0, 2));
    // Round up value
    approx_radius = round(diagonal_square*10.0) / 10.0 + 0.1;

    return d2i(approx_radius);
}

void compute_centers_of_approximation_circles(ST_RECTANGLE veh_rect, ST_IPOINT &amp;centers[2]) {
    double disc_radius, distance_centers, veh_cent_x_double, veh_cent_y_double;

    disc_radius = i2d(compute_approximating_circle_radius(veh_rect.length, veh_rect.width));
    distance_centers = disc_radius/2.0;

    // Compute the center position of first circle (front)
    veh_cent_x_double = i2d(veh_rect.center.x);
    veh_cent_y_double = i2d(veh_rect.center.y);
    centers[0].x = d2i(veh_cent_x_double + (distance_centers/2.0)*cos(i2d(veh_rect.orientation)));
    centers[0].y = d2i(veh_cent_y_double + (distance_centers/2.0)*sin(i2d(veh_rect.orientation)));

    // Compute the center position of second circle (rear)
    centers[1].x = d2i(veh_cent_x_double - (distance_centers/2.0)*cos(i2d(veh_rect.orientation)));
    centers[1].y = d2i(veh_cent_y_double - (distance_centers/2.0)*sin(i2d(veh_rect.orientation)));
}

bool check_collision(ST_RECTANGLE veh_st_rect1, ST_RECTANGLE veh_st_rect2, int32_t dis_thres) {    
    // define two vehicles' circle tuple (front and rear)
    ST_IPOINT veh_circle_tuple1[2] = {{0, 0}, {0, 0}};
    ST_IPOINT veh_circle_tuple2[2] = {{0, 0}, {0, 0}};
    double min_dis = FLT_MAX, dis = 0;
    int i, j;    
    
    // calculate the centers of the vehicles' circles
    compute_centers_of_approximation_circles(veh_st_rect1, veh_circle_tuple1);
    compute_centers_of_approximation_circles(veh_st_rect2, veh_circle_tuple2);

    for (i = 0; i &lt; 2; ++i) {
        for (j = 0; j &lt; 2; ++j) {
            dis = sqrt(pow(veh_circle_tuple1[i].x - veh_circle_tuple2[j].x, 2) + pow(veh_circle_tuple1[i].y - veh_circle_tuple2[j].y, 2));
            min_dis = fmin(min_dis, dis);
        }
    }
    if (dis_thres &gt; min_dis)
        return true;
    else
        return false;
}

void updateAll(int32_t &amp;vx, int32_t &amp;vy, int32_t &amp;vv, int32_t &amp;vacc, int32_t &amp;vdir, 
            const int32_t vaccRate, const int32_t vdirRate, const int8_t times){
    int i = 0, LEN = 0;    
    double rx=0,ry=0,rv=0,racc=0,rdir=0;
    double dx=0,dy=0,dv=0,dacc=0,ddir=0;
    double raccRate=0,rdirRate=0,step=0;
    const double granularity = 0.01;
    // assign the continuous variables with the discrete variables' values
    rx = i2d(vx);
    ry = i2d(vy);
    rv = i2d(vv);
    racc = i2d(vacc);
    rdir = i2d(vdir);
    raccRate = i2d(vaccRate);
    rdirRate = i2d(vdirRate);
    // setup the granularity for calculating integration
    step = times*granularity;
    LEN = fint(1/granularity);
    // integration
    for(i=0;i&lt;LEN;i++) {
        dacc = raccRate * step;
        ddir = rdirRate * step;
        racc = racc + dacc;
        rdir = rdir + ddir;
        //rdir_mod = i2d(d2i(rdir)%PI);
        dv = racc * step;
        rv = rv + dv;
        dx = rv * cos(rdir) * step;
        rx = rx + dx;
        dy = rv * sin(rdir) * step;
        ry = ry + dy;
    }
    // update discrete variables with the continuous variables' values
    vx = d2i(rx);
    vy = d2i(ry);
    vv = d2i(rv);
    vacc = d2i(racc);
    vdir = d2i(rdir);
}

void updateVA(int32_t &amp;vv, int32_t &amp;vacc, const int32_t vaccRate, const int8_t times){
    int i = 0, LEN = 0;
    double rx,ry,rv,racc;
    double dx,dy,dv,dacc,raccRate,step;
    const double granularity = 0.01;
    // assign the continuous variables with the discrete variables' values
    rv = i2d(vv);
    racc = i2d(vacc);
    raccRate = i2d(vaccRate);
    // setup the granularity for calculating integration
    step = times*granularity;
    LEN = fint(1/granularity);
    // integration
    for(i=0;i&lt;LEN;i++) {
        dacc = raccRate * step;
        racc = racc + dacc;
        dv = racc * step;
        rv = rv + dv;
    }
    // update discrete variables with the continuous variables' values
    vv = d2i(rv);
    vacc = d2i(racc);
}

void detect(){
    int i = 0;
    int32_t distance = 0;

    for(i = 0; i &lt; MAXOBS; i++){
        distance = getDisP2P(cps_i_state.position, obs_i_state[i].position);
        if(distance &lt;= d2i(RADAR)){
            cps_i_state.detection.collide |= check_collision(cps_shape, obs_shape[i], d2i(THRESHOLD_COLLISION));
        }
    }
    cps_i_state.detection.outside = !check_inlane_laneNet(cps_shape);
    cps_i_state.detection.reach = (getDisP2P(cps_shape.center, planning.goal) &lt;= d2i(THRESHOLD_REACH));
    if(staticObsExists) {
        for(i = 0; i &lt; MAXSO; i++) {
            cps_i_state.detection.collide |= check_collision(cps_shape, staticObs[i], d2i(THRESHOLD_COLLISION));
            distanceToStaticObs = getDisP2P(cps_i_state.position, staticObs[i].center);
        }
    }
}

bool isRisky(){
    int32_t i = 0, co = 16;
    bool re_risky = true;

    for(i = 0; i &lt; MAXOBS &amp;&amp; re_risky; i++){
        re_risky = getDisP2P(cps_i_state.position, obs_i_state[i].position) &gt; d2i(co*THRESHOLD_COLLISION); // "co" needs to be tuned in different models
        re_risky &amp;= check_inlane_laneNet(cps_shape);
    }

    return re_risky;
}

bool isProgress(){
    int32_t dis = 0;
    bool re_progress = false;

    dis = getDisP2P(cps_shape.center, planning.goal);
    if(dis &lt; distanceToGoal){
        re_progress = true;
    }
    distanceToGoal = dis;

    return re_progress;
}

int giveShieldState(){
    int id = 0, j = 0;

    j = set_cps_state(cps_i_state.position.x, cps_i_state.position.y, cps_i_state.velocity,
              cps_i_state.orientation, cps_i_state.acceleration, cps_i_state.accRate, 
              cps_i_state.yawRate, cps_i_state.detection.collide, cps_i_state.detection.outside,
              cps_i_state.detection.reach);
    for(id = 0; id&lt;MAXOBS; id++){
        j = set_obs_state(id, obs_i_state[id].position.x, obs_i_state[id].position.y, obs_i_state[id].velocity,
              obs_i_state[id].orientation, obs_i_state[id].acceleration, obs_i_state[id].accRate, 
              obs_i_state[id].yawRate, obs_i_state[id].detection.collide, obs_i_state[id].detection.outside,
              obs_i_state[id].detection.reach);
    }
    
    return 1;
}

/*ST_ISTATE cps_i_state_copy;
ST_ISTATE obs_i_state_copy[MAXOBS];
int getShieldState(){
    int id = 0;

    cps_i_state_copy.position.x = get_cps_position_x();
    cps_i_state_copy.position.y = get_cps_position_y();
    cps_i_state_copy.velocity = get_cps_velocity();
    cps_i_state_copy.orientation = get_cps_orientation();
    cps_i_state_copy.acceleration = get_cps_acceleration();
    cps_i_state_copy.accRate = get_cps_accRate();
    cps_i_state_copy.yawRate = get_cps_yawRate();
    cps_i_state_copy.detection.reach = get_cps_detection_reach();
    cps_i_state_copy.detection.collide = get_cps_detection_collide();
    cps_i_state_copy.detection.outside = get_cps_detection_outside();
    for(id = 0; id&lt;MAXOBS; id++){
            obs_i_state_copy[id].position.x = get_obs_position_x(id);
            obs_i_state_copy[id].position.y = get_obs_position_y(id);
            obs_i_state_copy[id].velocity = get_obs_velocity(id);
            obs_i_state_copy[id].orientation = get_obs_orientation(id);
            obs_i_state_copy[id].acceleration = get_obs_acceleration(id);
            obs_i_state_copy[id].accRate = get_obs_accRate(id);
            obs_i_state_copy[id].yawRate = get_obs_yawRate(id);
            obs_i_state_copy[id].detection.reach = get_obs_detection_reach(id);
            obs_i_state_copy[id].detection.collide = get_obs_detection_collide(id);
            obs_i_state_copy[id].detection.outside = get_obs_detection_outside(id);
    }
    return id;
}*/

void updateShield(){
    int i = giveShieldState();
    //
    //i = getShieldState();
}</declaration>
	<template>
		<name x="5" y="5">Act_Move</name>
		<parameter>const act_id_t id</parameter>
		<declaration>int type[5];
int32_t value[5];
void shield(){
    updateShield();
    //getShieldState();
    get_action(type,value);
}

bool gearChanged(const int accRate){
    return (accRate&gt;0 &amp;&amp; cps_i_state.acceleration&lt;0) || (accRate&lt;0 &amp;&amp; cps_i_state.acceleration&gt;0) || 
           (accRate==0 &amp;&amp; cps_i_state.acceleration!=0 &amp;&amp; (cps_i_state.velocity&gt;=d2i(MAX_V)||cps_i_state.velocity&lt;=d2i(MIN_V)));
}

bool permit(acc_t gear){
    int i = 0;
    //int type[5];
    //int32_t value[5];

    //get_action(type,value);
    for(i = 0; i &lt; 5; i++){
        if(type[i] == M &amp;&amp; value[i] == gear){
            return true;
        }
    }
    return false;
}

bool can(acc_t gear){
    int32_t pre_v = cps_i_state.velocity, pre_acc = cps_i_state.acceleration, accRate = d2i(mTimeStep(gear)/ACC_GRA);

    if(!permit(gear) &amp;&amp; shielded){
        return false;
    }

    if(gearChanged(accRate)){
        pre_acc = 0;
    }
    updateVA(pre_v, pre_acc, accRate, N2*P);
    if(pre_v&lt;=MAX_V &amp;&amp; pre_v&gt;=MIN_V &amp;&amp; pre_acc&lt;=MAX_ACC &amp;&amp; pre_acc&gt;=MIN_ACC){
        return true;
    }else{}

    return false;
}

void act(acc_t gear){
    cps_i_state.accRate=d2i(mTimeStep(gear)/ACC_GRA);
    if(gearChanged(cps_i_state.accRate)){
        cps_i_state.acceleration = 0;
        cps_dynamic.acceleration = 0.0;
    }

    //updateShield();
    //getShieldState();
}</declaration>
		<location id="id0" x="-204" y="0">
			<name x="-221" y="25">Wait</name>
		</location>
		<location id="id1" x="-68" y="0">
			<name x="-93" y="25">Choose</name>
			<committed/>
		</location>
		<init ref="id0"/>
		<transition id="id2">
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="select" x="-161" y="-85">g:acc_t</label>
			<label kind="guard" x="-161" y="-68">can(g)</label>
			<label kind="assignment" x="-161" y="-51">act(g)</label>
			<nail x="-68" y="-68"/>
			<nail x="-204" y="-68"/>
		</transition>
		<transition id="id3">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-178" y="-25">perform[id]?</label>
			<label kind="assignment" x="-187" y="8">shield()</label>
		</transition>
	</template>
	<template>
		<name>Act_Turn</name>
		<parameter>const act_id_t id</parameter>
		<declaration>int l_type[5];
int32_t l_value[5];
void shield(){
    updateShield();
    //getShieldState();
    get_action(l_type,l_value);
}

bool permit(acc_t gear){
    int i = 0;
    //int l_type[5];
    //int32_t l_value[5];

    //get_action(l_type,l_value);
    for(i = 0; i &lt; 5; i++){
        if(l_type[i] == T &amp;&amp; l_value[i] == gear){
            return true;
        }
    }
    return false;
}

bool can(dir_t gear){
    if(!permit(gear) &amp;&amp; shielded){
        return false;
    }

    if(cps_i_state.velocity == 0 &amp;&amp; gear != 0){
        // the vehicle cannot turn without a speed
        return false;
    }
    return true;
}

void act(dir_t gear){
    cps_i_state.yawRate=d2i(mTimeStep(gear)/DIR_GRA);

    //updateShield();
    //getShieldState();
}

void reload(){
    distanceToGoal = getDisP2P(cps_shape.center, planning.goal);
}</declaration>
		<location id="id4" x="170" y="102">
			<name x="136" y="127">Choose</name>
			<committed/>
		</location>
		<location id="id5" x="34" y="102">
			<name x="17" y="127">Wait</name>
		</location>
		<init ref="id5"/>
		<transition id="id6">
			<source ref="id4"/>
			<target ref="id5"/>
			<label kind="select" x="76" y="17">g:dir_t</label>
			<label kind="guard" x="76" y="34">can(g)</label>
			<label kind="assignment" x="76" y="51">act(g)</label>
			<nail x="170" y="34"/>
			<nail x="34" y="34"/>
		</transition>
		<transition id="id7">
			<source ref="id5"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="59" y="76">perform[id]?</label>
			<label kind="assignment" x="51" y="110">shield()</label>
		</transition>
	</template>
	<template>
		<name>Controller</name>
		<parameter>const int[0,MAXL] initLane, const ST_DSTATE &amp;initCS, const ST_RECTANGLE &amp;shape, const ST_RULES &amp;rules</parameter>
		<declaration>act_id_t actID = 0;

void initDis() {
    ST_IPOINT leftTop = laneNet[initLane].left.points[0];
    ST_IPOINT rightTop = laneNet[initLane].left.points[1];
    ST_IPOINT rightDown = laneNet[initLane].right.points[0];
    ST_IPOINT leftDown = laneNet[initLane].right.points[1];
    ST_IPOINT middleDStart, middleDEnd;
    ST_IPOINT start;
    int32_t diffX = 0, diffY = 0;
    double xs, ys, xe, ye, angle;

    diffX = leftDown.x - leftTop.x;
    diffY = leftDown.y - leftTop.y;
    middleDStart.x = leftTop.x + diffX/2;
    middleDStart.y = leftTop.y + diffY/2;
    diffX = rightDown.x - rightTop.x;
    diffY = rightDown.y - rightTop.y;
    middleDEnd.x = rightTop.x + diffX/2;
    middleDEnd.y = rightTop.y + diffY/2;
    
    xs = i2d(middleDStart.x);
    ys = i2d(middleDStart.y);
    xe = i2d(middleDEnd.x);
    ye = i2d(middleDEnd.y);

    angle = atan2(ys-ye,xs-xe);

    if(initCS.position.x != NONE || initCS.position.y != NONE){
        start.x = d2i(initCS.position.x);
        start.y = d2i(initCS.position.y);
        angle = initCS.orientation;
    }else{
        start = middleDStart;
    }

    cps_i_state.position = start;
    cps_i_state.velocity = d2i(mTimeStep(initCS.velocity));
    cps_i_state.orientation = d2i(angle);
    cps_i_state.acceleration = d2i(mTimeStep(initCS.acceleration));
    cps_i_state.accRate = d2i(mTimeStep(initCS.accRate));
    cps_i_state.yawRate = d2i(mTimeStep(initCS.yawRate));
    cps_i_state.detection.collide = false;
    cps_i_state.detection.outside = false;
    cps_i_state.detection.reach = false;

    distanceToGoal = getDisP2P(cps_shape.center, planning.goal);

    cps_dynamic.x = i2d(start.x);
    cps_dynamic.y = i2d(start.y);
    cps_dynamic.velocity = mTimeStep(initCS.velocity);
    cps_dynamic.orientation = angle;
    cps_dynamic.acceleration = mTimeStep(initCS.acceleration);

    rSafe = 0;
    rProgress = 0;
}

void followShape(){
    cps_shape = shape;
    cps_shape.center = cps_i_state.position;
    cps_shape.orientation = cps_i_state.orientation;
}

void initialize(){
    initDis();
    followShape();

    //updateShield();
}

void sensor(){
    int i = 0, id = 0;

    updateAll(cps_i_state.position.x,cps_i_state.position.y,cps_i_state.velocity,cps_i_state.acceleration,cps_i_state.orientation,
           cps_i_state.accRate,cps_i_state.yawRate,P*N1);
    followShape();
    detect();

    //updateShield();
}

void reload(){
    actID = 0;
}</declaration>
		<location id="id8" x="68" y="0">
			<name x="25" y="-34">Choose</name>
			<committed/>
		</location>
		<location id="id9" x="-136" y="0">
			<name x="-195" y="-34">Acting</name>
		</location>
		<location id="id10" x="-17" y="-85">
			<name x="-27" y="-119">M1</name>
			<urgent/>
		</location>
		<location id="id11" x="-42" y="0">
			<name x="-59" y="-42">Ini</name>
		</location>
		<init ref="id11"/>
		<transition id="id12">
			<source ref="id10"/>
			<target ref="id8"/>
			<label kind="guard" x="-76" y="-68">actID&lt;MAXACT-1</label>
			<nail x="-17" y="0"/>
		</transition>
		<transition id="id13" controllable="false">
			<source ref="id11"/>
			<target ref="id9"/>
			<label kind="synchronisation" x="-102" y="-25">start?</label>
			<label kind="assignment" x="-119" y="17">initialize()</label>
		</transition>
		<transition id="id14">
			<source ref="id10"/>
			<target ref="id9"/>
			<label kind="guard" x="-170" y="-102">actID==MAXACT-1</label>
			<label kind="synchronisation" x="-170" y="-119">perform[actID]!</label>
			<label kind="assignment" x="-170" y="-85">reload()</label>
			<nail x="-136" y="-85"/>
		</transition>
		<transition id="id15" controllable="false">
			<source ref="id9"/>
			<target ref="id9"/>
			<label kind="synchronisation" x="-195" y="-17">sense?</label>
			<label kind="assignment" x="-195" y="17">sensor()</label>
			<nail x="-170" y="0"/>
			<nail x="-170" y="25"/>
		</transition>
		<transition id="id16" controllable="false">
			<source ref="id9"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-85" y="51">decide?</label>
			<nail x="-136" y="68"/>
			<nail x="68" y="68"/>
		</transition>
		<transition id="id17">
			<source ref="id8"/>
			<target ref="id10"/>
			<label kind="synchronisation" x="8" y="-119">perform[actID]!</label>
			<label kind="assignment" x="8" y="-102">actID++</label>
			<nail x="68" y="-85"/>
		</transition>
	</template>
	<template>
		<name>Timer</name>
		<declaration>clock t;
/*ST_ISTATE cps_i_state_local;
ST_ISTATE cps_i_state_copy;
ST_ISTATE obs_i_state_local[MAXOBS+1];
ST_ISTATE obs_i_state_copy[MAXOBS+1];*/

bool ToDecide(){
    if(distanceToGoal &lt;= 2*cps_i_state.velocity){
        return count%N1==0 &amp;&amp; count%MAXTIME!=0;
    }
    return count == 1 || (count%N2==0 &amp;&amp; count%MAXTIME!=0);
}

bool ToEnd(){
    return FRISKY &lt; 0 || FPROGRESS &lt; 0 || cps_i_state.detection.outside || cps_i_state.detection.collide || cps_i_state.detection.reach || count&gt;=MAXTIME;
}












</declaration>
		<location id="id18" x="-68" y="0">
			<name x="-102" y="-51">Counting</name>
			<label kind="invariant" x="-59" y="8">t&lt;=P</label>
		</location>
		<location id="id19" x="136" y="0">
			<name x="110" y="-51">Judge</name>
			<urgent/>
		</location>
		<location id="id20" x="-153" y="0">
			<name x="-163" y="-34">S</name>
			<urgent/>
		</location>
		<location id="id21" x="238" y="0">
			<name x="221" y="-34">Done</name>
		</location>
		<init ref="id20"/>
		<transition id="id22" controllable="false">
			<source ref="id19"/>
			<target ref="id21"/>
			<label kind="guard" x="153" y="-25">ToEnd()</label>
			<label kind="synchronisation" x="161" y="0">end!</label>
		</transition>
		<transition id="id23" controllable="false">
			<source ref="id20"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-136" y="-25">start!</label>
		</transition>
		<transition id="id24" controllable="false">
			<source ref="id19"/>
			<target ref="id18"/>
			<label kind="guard" x="-51" y="42">!ToEnd()&amp;&amp;ToDecide()</label>
			<label kind="synchronisation" x="0" y="25">decide!</label>
			<nail x="136" y="68"/>
			<nail x="-68" y="68"/>
		</transition>
		<transition id="id25" controllable="false">
			<source ref="id19"/>
			<target ref="id18"/>
			<label kind="guard" x="-51" y="-25">!ToEnd()&amp;&amp;!ToDecide()</label>
		</transition>
		<transition id="id26" controllable="false">
			<source ref="id18"/>
			<target ref="id19"/>
			<label kind="guard" x="-59" y="-85">t&gt;=P</label>
			<label kind="synchronisation" x="-8" y="-85">sense!</label>
			<label kind="assignment" x="59" y="-85">t=0,count++</label>
			<nail x="-68" y="-68"/>
			<nail x="136" y="-68"/>
		</transition>
	</template>
	<template>
		<name>Dynamics</name>
		<location id="id27" x="95" y="0">
			<name x="83" y="-34">S1</name>
			<label kind="invariant" x="-272" y="136">cps_dynamic.x'==0 &amp;&amp;
cps_dynamic.y'==0 &amp;&amp;
cps_dynamic.velocity'==0 &amp;&amp;
cps_dynamic.acceleration'==0 &amp;&amp;
cps_dynamic.orientation'==0</label>
		</location>
		<location id="id28" x="0" y="0">
			<name x="-10" y="-34">S0</name>
			<label kind="invariant" x="-272" y="25">cps_dynamic.x'==cos(cps_dynamic.orientation)*cps_dynamic.velocity &amp;&amp;
cps_dynamic.y'==sin(cps_dynamic.orientation)*cps_dynamic.velocity &amp;&amp;
cps_dynamic.velocity'==cps_dynamic.acceleration &amp;&amp;
cps_dynamic.acceleration'==i2d(cps_i_state.accRate) &amp;&amp;
cps_dynamic.orientation'==i2d(cps_i_state.yawRate)</label>
		</location>
		<init ref="id28"/>
		<transition id="id29" controllable="false">
			<source ref="id28"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="25" y="-25">end?</label>
		</transition>
	</template>
	<template>
		<name>Obstacle</name>
		<parameter>const obs_id_t id, const ST_DSTATE &amp;initCS, const ST_RECTANGLE &amp;shape, const ST_PAIR &amp;trajectory[MAXTP]</parameter>
		<declaration>uint8_t pc = 0;     // policy counter
uint8_t tc = 0;     // time counter

void followShape(){
    obs_shape[id].center = obs_i_state[id].position;
    obs_shape[id].orientation = obs_i_state[id].orientation;
}

void decisionMaking() {
    if(pc &lt; MAXTP &amp;&amp; tc == trajectory[pc].time) {
        // predefined trajectory starts
        obs_dynamic[id].x = trajectory[pc].dState.position.x;
        obs_dynamic[id].y = trajectory[pc].dState.position.y;
        obs_dynamic[id].velocity = mTimeStep(trajectory[pc].dState.velocity);
        obs_dynamic[id].orientation = trajectory[pc].dState.orientation;

        obs_i_state[id].position.x = d2i(trajectory[pc].dState.position.x);
        obs_i_state[id].position.y = d2i(trajectory[pc].dState.position.y);
        obs_i_state[id].velocity = d2i(mTimeStep(trajectory[pc].dState.velocity));
        obs_i_state[id].orientation = d2i(trajectory[pc].dState.orientation);

        followShape();

        //obs_dynamic[id].acceleration = mTimeStep(trajectory[pc].dState.acceleration);
        //obs_dynamic[id].yawRate = mTimeStep(trajectory[pc].dState.yawRate);

        //obs_i_state[id].acceleration = d2i(mTimeStep(trajectory[pc].dState.acceleration));
        //obs_i_state[id].yawRate = d2i(mTimeStep(trajectory[pc].dState.yawRate));
        pc++;
    }
    else if(pc &lt; MAXTP) {
        tc++;
    }
    else if(pc &gt;= MAXTP - 1) {
        obs_dynamic[id].velocity = 0;
        obs_dynamic[id].orientation = 0;
        //obs_dynamic[id].acceleration = 0;
        //obs_dynamic[id].yawRate = 0;
        obs_i_state[id].velocity = 0;
        obs_i_state[id].orientation = 0;
        //obs_i_state[id].acceleration = 0;
        //obs_i_state[id].yawRate = 0;
        followShape();
    }
}

void initCon() {
    obs_dynamic[id].x = initCS.position.x;
    obs_dynamic[id].y = initCS.position.y;
    obs_dynamic[id].velocity = mTimeStep(initCS.velocity);
    obs_dynamic[id].orientation = initCS.orientation;
    //obs_dynamic[id].acceleration = mTimeStep(initCS.acceleration);
    //obs_dynamic[id].yawRate = mTimeStep(initCS.yawRate); 
}

void initDis() {
    obs_i_state[id].position.x = d2i(initCS.position.x);
    obs_i_state[id].position.y = d2i(initCS.position.y);
    obs_i_state[id].velocity = d2i(mTimeStep(initCS.velocity));
    obs_i_state[id].orientation = d2i(initCS.orientation);
    //obs_i_state[id].acceleration = d2i(mTimeStep(initCS.acceleration));
    //obs_i_state[id].yawRate = d2i(mTimeStep(initCS.yawRate));
}

void updateDis() {
    // real numbers of the current state
    double vx = 0.0, vy = 0.0;
    double rVelocity = 0.0;
    double rOrientation = 0.0;
    // int/real numbers of velocity on X and Y axes
    int32_t dVx = 0, dVy = 0;

    // update discrete velocity and orientation
    //obs_i_state[id].velocity = obs_i_state[id].velocity + obs_i_state[id].acceleration * P;
    //obs_i_state[id].orientation = obs_i_state[id].orientation + obs_i_state[id].yawRate * P;
    // conversion to real numbers
    rVelocity = i2d(obs_i_state[id].velocity);
    rOrientation = i2d(obs_i_state[id].orientation);
    //rAcceleration = i2d(obs_i_state[id].acceleration);
    //rYawRate = i2d(obs_i_state[id].yawRate);
    // velocity projection
    vx = rVelocity*cos(rOrientation);
    vy = rVelocity*sin(rOrientation);
    dVx = d2i(vx);
    dVy = d2i(vy);
    // update other discrete varaibles
    obs_i_state[id].position.x = obs_i_state[id].position.x + dVx * P*N1;
    obs_i_state[id].position.y = obs_i_state[id].position.y + dVy * P*N1;
    followShape();
}

void initialize() {
    pc = 0;
    tc = 0;
    initDis();
    initCon();
    obs_shape[id] = shape;
    followShape();

    //updateShield();
}

void change(){
    updateDis();
    decisionMaking();
}</declaration>
		<location id="id30" x="119" y="0">
			<name x="109" y="-34">S1</name>
			<label kind="invariant" x="-323" y="136">obs_dynamic[id].x'==0 &amp;&amp;
obs_dynamic[id].y'==0 &amp;&amp;
obs_dynamic[id].velocity'==0 &amp;&amp;
obs_dynamic[id].acceleration'==0 &amp;&amp;
obs_dynamic[id].orientation'==0</label>
		</location>
		<location id="id31" x="0" y="0">
			<name x="-10" y="-34">S0</name>
			<label kind="invariant" x="-323" y="25">obs_dynamic[id].x'==cos(i2d(obs_i_state[id].orientation))*i2d(obs_i_state[id].velocity)&amp;&amp;
obs_dynamic[id].y'==sin(i2d(obs_i_state[id].orientation))*i2d(obs_i_state[id].velocity)&amp;&amp;
obs_dynamic[id].velocity'==0 &amp;&amp;
obs_dynamic[id].acceleration'==0 &amp;&amp;
obs_dynamic[id].orientation'==0</label>
			<label kind="comments" x="-144" y="-102">Obstacle with a predefined trajectory</label>
		</location>
		<init ref="id31"/>
		<transition id="id32" controllable="false">
			<source ref="id31"/>
			<target ref="id30"/>
			<label kind="synchronisation" x="42" y="-17">end?</label>
		</transition>
		<transition id="id33" controllable="false">
			<source ref="id31"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="25" y="-68">sense?</label>
			<label kind="assignment" x="25" y="-51">change()</label>
			<nail x="34" y="-34"/>
			<nail x="68" y="-34"/>
		</transition>
		<transition id="id34" controllable="false">
			<source ref="id31"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="-102" y="-68">start?</label>
			<label kind="assignment" x="-102" y="-51">initialize()</label>
			<nail x="-34" y="-34"/>
			<nail x="-68" y="-34"/>
		</transition>
	</template>
	<template>
		<name>Rewards</name>
		<declaration>void penalty(){
    bool re_risky = false;
    bool re_progress = false;

    re_risky = isRisky();
    re_progress = isProgress();

    //normal
    if(re_risky &amp;&amp; re_progress){
        FRISKY = 1;
        FPROGRESS = 1;
    }
    //risky
    if(!re_risky){
        FRISKY = -10;
        FPROGRESS = 0;
    }
    //no progress
    if(re_risky &amp;&amp; !re_progress){
        FRISKY = 1;
        FPROGRESS = -10;
    }

    if(cps_i_state.detection.collide || cps_i_state.detection.outside){
        FRISKY = -100;
    }
    if(cps_i_state.detection.reach){
        FPROGRESS = 100;
    }

    //reward = 10*re_risky+(5+1000*cps_i_state.detection.reach)*re_progress;
}

void terminate(){
    if(!cps_i_state.detection.reach){
        FPROGRESS = -100;
        //reward -= 100;
    }else{
        FPROGRESS = 100;  
        //reward += 100;      
    }
}</declaration>
		<location id="id35" x="0" y="0">
			<name x="-25" y="-8">L</name>
			<label kind="invariant" x="34" y="-17">rSafe'==FRISKY&amp;&amp;
rProgress'==FPROGRESS</label>
		</location>
		<init ref="id35"/>
		<transition id="id36" controllable="false">
			<source ref="id35"/>
			<target ref="id35"/>
			<label kind="synchronisation" x="-16" y="17">end?</label>
			<label kind="assignment" x="-34" y="34">terminate()</label>
			<nail x="-34" y="34"/>
			<nail x="34" y="34"/>
		</transition>
		<transition id="id37" controllable="false">
			<source ref="id35"/>
			<target ref="id35"/>
			<label kind="synchronisation" x="-25" y="-68">sense?</label>
			<label kind="assignment" x="-34" y="-51">penalty()</label>
			<nail x="-34" y="-34"/>
			<nail x="34" y="-34"/>
		</transition>
	</template>
	<system>// Generated moving obstacles starts
const ST_DSTATE initCS0 = {{17.0, 2.0}, 10.0, 0.0, 0.0, 0.0, 0.0};
const ST_RECTANGLE shapeObs0 = {{17000, 2000}, 2100, 4500, 0};
const ST_PAIR PHOLDER = {NONE,{{NONE,NONE},NONE,NONE,NONE,NONE,NONE}};
const ST_PAIR trajectory0[MAXTP] = {{1, {{18.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {2, {{19.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {3, {{20.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {4, {{21.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {5, {{22.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {6, {{23.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {7, {{24.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {8, {{25.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {9, {{26.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {10, {{27.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {11, {{28.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {12, {{29.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {13, {{30.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {14, {{31.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {15, {{32.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {16, {{33.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {17, {{34.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {18, {{35.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {19, {{36.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {20, {{37.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {21, {{38.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {22, {{39.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {23, {{40.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {24, {{41.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {25, {{42.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {26, {{43.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {27, {{44.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {28, {{45.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {29, {{46.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {30, {{47.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {31, {{48.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {32, {{49.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {33, {{50.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {34, {{51.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {35, {{52.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {36, {{53.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {37, {{54.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {38, {{55.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {39, {{56.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {40, {{57.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {41, {{58.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {42, {{59.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {43, {{60.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {44, {{61.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {45, {{62.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {46, {{63.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {47, {{64.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {48, {{65.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {49, {{66.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {50, {{67.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {51, {{68.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {52, {{69.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {53, {{70.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {54, {{71.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {55, {{72.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {56, {{73.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {57, {{74.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {58, {{75.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {59, {{76.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {60, {{77.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {61, {{78.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {62, {{79.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {63, {{80.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {64, {{81.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {65, {{82.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {66, {{83.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {67, {{84.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {68, {{85.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}, {69, {{86.0, 2.0}, 10.0, 0.02, 0.0, 0.0, 0.0}}};
obs0 = Obstacle(0, initCS0, shapeObs0, trajectory0);

// Generated moving obstacles ends

// Generated ego vehicle starts
const ST_DSTATE initEgo = {{50.1, 6.1}, 12.0, 0.0, 0.0, 0.0, 0.0};
const ST_RECTANGLE initShapeEgo = {{50100, 6100}, 1000, 3500, 0};
const ST_RULES rules = {d2i(4.0), 0, d2i(0.2), d2i(-0.2)}; 
const int[0,MAXL] initLane = 1;
move = Act_Move(0);
turn = Act_Turn(1);
controller = Controller(initLane,initEgo,initShapeEgo,rules);
timer = Timer();
dynamics = Dynamics();
rewardMachine = Rewards();
// Generated ego vehicle ends

// Generated model instances starts
system timer, obs0, move, turn, controller, dynamics, rewardMachine;

// Generated model instances ends
</system>
	<queries>
		<option key="--total-runs" value="200"/>
		<option key="--max-iterations" value="10"/>
		<option key="--good-runs" value="100"/>
		<option key="--eval-runs" value="200"/>
		<option key="--diagnostic" value="1"/>
		<query>
			<formula>//behaviour observation</formula>
			<comment/>
		</query>
		<query>
			<formula>A[] !cps_i_state.detection.collide</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2025-02-04 09:06:34 +0100">
				<option key="--total-runs" value="200"/>
				<option key="--max-iterations" value="10"/>
				<option key="--good-runs" value="100"/>
				<option key="--eval-runs" value="200"/>
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
		<query>
			<formula>A[] !cps_i_state.detection.outside</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2025-02-04 09:06:39 +0100">
				<option key="--total-runs" value="200"/>
				<option key="--max-iterations" value="10"/>
				<option key="--good-runs" value="100"/>
				<option key="--eval-runs" value="200"/>
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
		<query>
			<formula>A[] !cps_i_state.detection.collide &amp;&amp; !cps_i_state.detection.outside</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2025-02-04 09:16:16 +0100">
				<option key="--total-runs" value="200"/>
				<option key="--max-iterations" value="10"/>
				<option key="--good-runs" value="100"/>
				<option key="--eval-runs" value="200"/>
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
		<query>
			<formula>E[] !cps_i_state.detection.collide &amp;&amp; !cps_i_state.detection.outside</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2025-02-04 09:16:20 +0100">
				<option key="--total-runs" value="200"/>
				<option key="--max-iterations" value="10"/>
				<option key="--good-runs" value="100"/>
				<option key="--eval-runs" value="200"/>
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
		<query>
			<formula>E&lt;&gt; !cps_i_state.detection.collide &amp;&amp; !cps_i_state.detection.outside &amp;&amp; cps_i_state.detection.reach</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2025-02-04 09:16:25 +0100">
				<option key="--total-runs" value="200"/>
				<option key="--max-iterations" value="10"/>
				<option key="--good-runs" value="100"/>
				<option key="--eval-runs" value="200"/>
				<option key="--diagnostic" value="1"/>
			</result>
		</query>
	</queries>
</nta>
